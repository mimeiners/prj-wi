## Die Spielsteuerung des Kickers

Die Spielsteuerung ist die zentrale Logik des Kickers. Sie besteht aus sechs python-Skripts, die in drei Ebenen oder Level unterteilt sind: 
- Level 1: die oberste Ebene, in der alle Threads gestartet werden
- Level 2: Subsysteme, die parallel ausgefÃ¼hrt werden
- Level 3: hier sind globale Variablen vorhanden, auf die mehrere LVL2-Programme zugreifen; sowie Ãœbersicht Ã¼ber die Routinen und Reaktionen auf Events in Level 2

Diese Hierarchie entsteht daraus, dass Variablen in ein Python-Skript importiert werden kÃ¶nnen, aber nicht wieder zurÃ¼ckgegeben werden kÃ¶nnen. Wenn ein Subsystem den Punktestand Ã¤ndert, und ein anderes diesen auslesen will, muss dieser Wert in einer Import-Ebene unter beiden liegen - dafÃ¼r ist Level 3 vorhanden. Diese Problematik gÃ¤be es mit einer einzigen Datei nicht; der Ãœbersicht halber wurden die Subsysteme aber aufgeteilt. AuÃŸerdem ermÃ¶glicht die Aufteilung ein besseres Arbeiten mit GIT, da einfacher an mehreren Dateien gleichzeitig gearbeitet werden kann, ohne viele merge conflicts zu erzeugen.

**ABBILDUNG ZU DEN THREADS** ðŸ…¾

### Hauptdatei (LVL1_threads.py)
Diese Datei ist die Datei, von der aus alles aufgerufen wird und Threads gestartet werden. Diese Datei sollte automatisch nach booten des Pis gestartet werden, um Spiele zu ermÃ¶glichen. **Dieses Skript muss als Admin ausgefÃ¼hrt werden, da GPIO in LVL2 sonst nicht verwendet werden kann.**
Eine Ausnahme der Skript-Anordnung stellt hier die Not-Aus-Routine dar, da sie nicht auf Level 2 sondern auch in Level 1 enthalten ist. Dadurch wird gewÃ¤hrleistet, dass die Funktion immer verfÃ¼gbar ist und nicht eine andere Datei durch ihr Fehlen die Not-Aus-Funktion beeintrÃ¤chtigt. (Das System wurde auÃŸerhalb des Labors nicht in Betrieb genommen und der Taster wurde nicht eingebaut. Es war auch ein normaler Taster und kein geeigneter Unterbrecher.)

### Torerkennung (LVL2_goal_detection.py)
Zwei Pins des GPIO des Raspberrys werden auf LOW geprÃ¼ft, was beduetet, dass ein Reflektionslichttaster in der BallrÃ¼ckgabe ausgelÃ¶st wurde. **Muss als Admin ausgefÃ¼hrt werden (bzw. LVL1, das LVL2 importiert).**
Der Code ist sehr Ã¼bersichtlich und einfach zu verstehen. Die Funktion ```init()``` muss aufgerufen werden, bevor der restliche Code in ```goal()``` benutzt werden kann. ```GPIO.setmode(GPIO.BOARD)``` bedeutet, dass als Pinnummern nicht der Name des Pins (z. B. GPIO26), sondern die Position verwendet wird. Alle geraden Pinnummern sind in der rechten Spalte des GPIOs und alle ungeraden links. Pin 40 ist der letzte Pin.
```goal()``` ist die Funktion, die als Thread endlos laufen soll. Ist die [Spielphase](#spielphase) "ingame", werden konstant die beiden GPIO-Pins geprÃ¼ft, an denen die Datenpins der beiden Sensoren zur Torerkennung angeschlossen sind. LÃ¶st ein Sensor aus (Pin fÃ¤llt auf LOW), wird die Funktion ```lvl3.react_goal()``` mit der Nummer des Spielers aufgerufen. LÃ¤uft kein Spiel, ist die Funktion im idle-Zustand (beobachte CPU-Vollast in einzelnen Kernen kÃ¶nnte evtl. hierdurch entstehen, nicht Ã¼berprÃ¼ft).

### Kurbelerkennung (LVL2_foul_detection.py)
Die Kurbelerkennung besteht aus der Sicht des Kickers nur aus zwei Arduinos, die bei einem Foul HIGH melden. Zwei Pins des GPIO des Raspberrys werden konstant bei "ingame" auf HIGH geprÃ¼ft, was beduetet, dass der Arduino einer Spielerseite ein Kurbeln des Spielers detektiert hat.
Restliche FunktionalitÃ¤t ist durch Doku der [Torerkennung](#torerkennung-lvl2_goal_detectionpy) zu verstehen.

### Interface (LVL2_interface.py)
War angedacht zur TCP Kommunikation mit einem zweiten Rechner (AuVAReS auf NVIDIA Jetson). So wird der zweite Rechner Ã¼ber Spielevents informiert und kann selber auch SchlÃ¼sselwÃ¶rter senden, um den Spielablauf zu beeinflussen.

**>>> Doku by M.O. goes here <<<** ðŸ…¾

### Spielkonfiguration (LVL2_pregame.py)
Bevor das Spiel startet, mÃ¼ssen bspw. Spielernamen eingetragen werden. Dieses Skript durchlÃ¤uft die Vorbereitung des Spiels schrittweise und startet jedes Spiel. Mit der Website wird Ã¼ber game_data.json kommuniziert. Es waren leider keine Web-Developer im Team und daher ist diese fragwÃ¼rdige Methode nicht ersetzt wurden und wurde so hingenommen. Ob die Lebensdauer der SD-Karte durch die vielen Zugriffe auf diese Datei sinkt, wurde nicht geprÃ¼ft oder beachtet.
Die einzige Funktion ``pregame()`` lÃ¤uft endlos als Thread. Sie ist lang aber linear gegliedert; die Schritte 1 bis 5 passieren in der Phase "wait_pregame" (Achtung: im Code ist eine andere Nummerierung, es geht hier nur um die Reihenfolge).

0. Nach dem Poweron wird der [Systemstatus](#spielphase) auf "wait_pre" gesetzt. Die "init"-Phase lieÃŸe sich hier zeitlich verlÃ¤ngern, falls noch mehr Vorbereitungen getroffen werden mÃ¼ssen. Dieses Umschalten passiert einmalig, da die Phase "init" nur automatisch nach dem Poweron besteht.
1. Spielernamen: Die JSON-Datei wird beobachtet und sobald Spielernamen auftauchen, werden diese in python Ã¼bernommen.
2. Website Button zum Drohnen-Akku: Hier wird gewartet, bis "button_power" in der JSON auf True gesetzt wird. Das passiert durch DrÃ¼cken des ersten BestÃ¤tigungs-Buttons auf der Website, auch wenn keine Drohne vorhanden ist. FÃ¼r diese Abfrage gibt es keinen Timeout und es wird endlos auf True gewartet. AnschlieÃŸend wird AuVAReS das Keyword "notify_drone_powered" zugesendet.
3. AuVAReS abwarten: Besteht eine Verbindung zum Jetson-Board, wird die Antwort von AuVAReS abgewartet. Wir warten hier, dass die Drohne sich mit dem Board verbunden hat, bevor Schritt 4 kommt.
4. Der zweite Button muss gedrÃ¼ckt werden und setzt "button_start" auf True. Eine Art rechtliche Absicherung, dass der Nutzer die Drohne freigibt, da unser System nicht prÃ¼fen kann, ob jemand durch den Start der Drohne gefÃ¤hrdet wÃ¤re.
5. AuVAReS wird darÃ¼ber benachrichtigt und wir warten auf Antwort, dass die Drohne sich erfolgreich in Position begeben hat.
6. Spielstart: Der unix time stamp wird als GameID gespeichert. Damit sind die Spielereignisse in der Datenbank einem Spiel zuordenbar. In der JSON werden die Button-Werte zurÃ¼ckgesetzt, damit das nÃ¤chste Spiel nicht automatisch das pregame durchlÃ¤uft. In python werden TorzÃ¤hlervariablen auf null gesetzt und in die Datenbank wird eine neues Spiel mit Spielernamen und Toren (noch 0:0) geschrieben. Der Spielstatus wird auf "ingame" gesetzt. Jetzt startet das richtige Kickerspiel.

Ãœber die Website kann das Spiel jederzeit abgebrochen werden. Da `pregame()` wÃ¤hrend der aktiven Spielphase eigentlich idle ist, kann die ÃœberprÃ¼fung des Buttons hier Ã¼bernommen werden. Es passieren Ã¤hnliche Schritte wie bei der normalen Beendigung eines Spiels, wie etwa auch das LÃ¶schen der Spielernamen aus der JSON. Hier taucht besonders hÃ¤ufig ein Fehler auf, bei dem "button_stop" nicht erfolgreich aus der JSON gelesen werden konnte, vermutlich aufgrund zeitgleicher Zugriffe durch die Website oder eines Fehlers im Code der Website, der den Wert aus der JSON lÃ¶scht.

### Variablen und Routinen (LVL3_classes.py)
Der Name der Datei stammt aus den AnfÃ¤ngen, als viele Funktionen als Klassen zusammengefasst waren. Hier sind globale Variablen vorhanden, auf die mehrere LVL2-Programme zugreifen; sowie Ãœbersicht Ã¼ber die Routinen und Reaktionen auf Events in Level 2. So soll innerhalb einer Datei die Gesamtheit an Reaktionen auf Spielereignisse erkenntlich sein. In Level 2 werden Ereignisse detektiert oder ausgelÃ¶st und die Reaktion darauf findet sich in Level 3. ðŸ…¾

##### init()

#### connection
##### _find_connection()
##### server_send()
##### set_connection_status()

#### Spielphase
##### set_status()

#### event reactions
##### react_goal()
##### react_foul()
##### react_drone_connected() & react_drone_wants_gamestart
##### react_drone_pleasewait & react_drone_pleaseresume

#### Database & Website
##### database_write()
##### json_read()
##### json_write()